---
layout: single
title:  "재귀(Recursion)"
---


### **들어가기 앞서**

오늘은 재귀에 대해서 배웠는데, 재귀는 간단히 말해서 러시아 인형을 생각해 보면 본다. 자신의 복사본을 호출하여 더 작은 문제를 풀게함으로써 문제를 해결하는 방식이다. 머릿속에서만 생각하면 헷갈리지만 하나 하나 적어보며 정리하면 서 공부하니 이해하기가 수월하였다. 

### **오늘의 학습!**

**재귀함수?**
- 함수가 자신을 다시 호출하는 구조로 만들어진 함수이다.   
- 재귀함수는 종료조건이 있어야 하며, 종료조건을 설정해주지 않으면 무한 반복을 하게된다.   
- 재귀함수로 작성이 되는 코드는 반복문으로도 작성할 수 있다.
<br></br>

**왜 재귀를 사용하는가?**
- 재귀 코드는 반복 코드보다 짧고 작성하기 쉽다.  
- 예를 들어, 정렬, 검색, 그리고 탐색 문제들이 간단한 재귀 해법으로 해결된다.
<br></br>

**재귀는 언제 사용하면 좋을까?**
- 주어진 문제를 비슷한 구조의 더 작은 문제로 나눌 수 있는 경우  
- 중첩된 반복문이 많거나 반복문의 중첩 횟수를 예측하기 어려운 경우
<br></br>

**재귀vs반복문**
| 장점 | - 상대적으로 간결한 코드 | - 속도가 상대적으로 빠름 |
| --- | --- | --- |
| 단점 | - 메모리를 많이 사용함  | - 속도가 상대적으로 느림 | 상대적으로 복잡한 코드 |

<br></br>

**재귀적으로 사고하기!**
1. 재귀 함수의 입력값과 출력값 정의하기 (가장 단순하게)
2. 문제를 쪼개고 경우의 수를 나누기
3. 단순한 문제 해결하기 (base case -> 재귀 탈출조건 구성)
4. 복잡한 문제 해결하기 
5. 코드 구현하기

```javascript
function arrSum(arr) {
  //Base Case : 문제를 더 이상 쪼갤 수 없는 경우 (재귀의 기초)
  if (arr의 길이가 0인 경우) {
    return 0;
  }
  /*
  * Recursive Case : 그렇지 않은 경우
  * 문제를 더 이상 쪼갤 수 없는 경우
  * head: 배열의 첫 요소
  * tail: 배열의 첫 요소만 제거된 배열
  */
  return head + arrSum(tail);
}
```
